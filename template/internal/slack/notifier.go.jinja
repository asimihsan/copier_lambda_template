package slack

import (
	"fmt"
	"time"

	"github.com/dustin/go-humanize"
	"github.com/hashicorp/go-multierror"
	"github.com/slack-go/slack"
	"{{ github_path }}/internal/repository"
	"{{ github_path }}/internal/rotationutil"
)

// RotationNotifier handles sending notifications about rotations
type RotationNotifier struct {
	slackClient *slack.Client
}

// NewRotationNotifier creates a new rotation notifier
func NewRotationNotifier(slackClient *slack.Client) *RotationNotifier {
	return &RotationNotifier{
		slackClient: slackClient,
	}
}

// FormatDate formats a date with day of week
func FormatDate(t time.Time) string {
	return t.Format("Mon, Jan 2 2006")
}

// FormatDateRange formats a date range with duration
func FormatDateRange(from, to time.Time) string {
	duration := to.Sub(from)
	days := int(duration.Hours() / 24)
	return fmt.Sprintf("%s to %s (%d days)", 
		FormatDate(from), 
		FormatDate(to),
		days)
}

// TimeUntil returns human-friendly time until a date
func TimeUntil(t time.Time) string {
	return humanize.Time(t)
}

// AnnounceRotation broadcasts rotation info to a channel and/or direct messages
// Returns the generated message text and any error
func (n *RotationNotifier) AnnounceRotation(rotation *repository.Rotation, dmParticipants bool) (string, error) {
	// Find the next owner
	nextOwnerIndex := 0
	for i, ownerID := range rotation.RotationOrder {
		if ownerID == rotation.CurrentOwner {
			nextOwnerIndex = (i + 1) % len(rotation.RotationOrder)
			break
		}
	}
	nextOwner := rotation.RotationOrder[nextOwnerIndex]
	
	// Calculate next owner's dates
	nextOwnerFrom := rotation.NextRotationDate
	nextOwnerTo := rotationutil.CalculateNextRotationDate(nextOwnerFrom, rotation.Frequency)
	
	// Format the announcement message
	msg := fmt.Sprintf("ðŸ”„ *Rotation Update: `%s`*\n\n", rotation.RotationLabel)
	msg += fmt.Sprintf("â€¢ *Current owner:* <@%s>\n", rotation.CurrentOwner)
	msg += fmt.Sprintf("â€¢ *Current period:* %s\n", FormatDateRange(rotation.LastRotationDate, rotation.NextRotationDate))
	msg += fmt.Sprintf("â€¢ *Handover:* %s (%s)\n\n", FormatDate(rotation.NextRotationDate), TimeUntil(rotation.NextRotationDate))
	msg += fmt.Sprintf("â€¢ *Next owner:* <@%s>\n", nextOwner)
	msg += fmt.Sprintf("â€¢ *Next period:* %s", FormatDateRange(nextOwnerFrom, nextOwnerTo))
	
	// Send to channel if configured
	var result error
	if rotation.SlackChannelID != "" {
		_, _, channelErr := n.slackClient.PostMessage(
			rotation.SlackChannelID,
			slack.MsgOptionText(msg, false),
		)
		result = multierror.Append(result, channelErr)
	}
	
	// Direct message to relevant parties if requested
	if dmParticipants {
		// DM current owner
		_, _, currentOwnerErr := n.slackClient.PostMessage(
			rotation.CurrentOwner,
			slack.MsgOptionText(fmt.Sprintf("*Reminder:* You are the current owner of rotation `%s` until %s (%s).", 
				rotation.RotationLabel, 
				FormatDate(rotation.NextRotationDate),
				TimeUntil(rotation.NextRotationDate)), 
			false),
		)
		result = multierror.Append(result, currentOwnerErr)
		
		// DM next owner
		_, _, nextOwnerErr := n.slackClient.PostMessage(
			nextOwner,
			slack.MsgOptionText(fmt.Sprintf("*Heads up:* You will become the owner of rotation `%s` on %s (%s).", 
				rotation.RotationLabel, 
				FormatDate(rotation.NextRotationDate),
				TimeUntil(rotation.NextRotationDate)), 
			false),
		)
		result = multierror.Append(result, nextOwnerErr)
	}
	
	return msg, result
}
