package slack
 
import (
	"context"
	"fmt"
	"regexp"
	"strconv"
	"strings"
	"time"

	"github.com/slack-go/slack"

	"{{ github_path }}/internal/repository"
)

// RotationCommand handles rotation-related commands.
type RotationCommand struct {
	repo        repository.RotationRepository
	slackClient *slack.Client // used for querying user info
}

var _ SlackCommandHandler = (*RotationCommand)(nil)

func NewRotationCommand(repo repository.RotationRepository, slackClient *slack.Client) *RotationCommand {
	return &RotationCommand{
		repo:        repo,
		slackClient: slackClient,
	}
}

func (c *RotationCommand) HandleCommand(ctx context.Context, cmd slack.SlashCommand) (slack.Msg, error) {
	args := strings.TrimSpace(cmd.Text)
	fields := strings.Fields(args)

	if len(fields) == 0 {
		msg := slack.Msg{
			ResponseType: slack.ResponseTypeEphemeral,
			Blocks: slack.Blocks{
				BlockSet: []slack.Block{
					slack.NewHeaderBlock(
						slack.NewTextBlockObject("plain_text", "Usage Instructions", false, false),
					),
					slack.NewSectionBlock(
						slack.NewTextBlockObject("mrkdwn", "*Usage:* `/rotation <command> [parameters]`", false, false),
						nil,
						nil,
					),
					slack.NewDividerBlock(),
					slack.NewSectionBlock(
						slack.NewTextBlockObject("mrkdwn", "*Available Commands:*", false, false),
						nil,
						nil,
					),
					slack.NewSectionBlock(
						slack.NewTextBlockObject("mrkdwn", "• `create` - Create a new rotation\n• `show` - Display the current rotation\n• `next` - Advance to the next person in the rotation\n• `add` - Add a person to the rotation\n• `remove` - Remove a person from the rotation\n• `move` - Move a person to a different position\n• `reorder` - Reorder the rotation\n• `setfrequency` - Set how often the rotation changes\n• `setowner` - Assign a new owner to the rotation", false, false),
						nil,
						nil,
					),
					slack.NewDividerBlock(),
					slack.NewSectionBlock(
						slack.NewTextBlockObject("mrkdwn", "For more details on each command, use `/rotation help <command>`.", false, false),
						nil,
						nil,
					),
				},
			},
		}

		return msg, nil
	}

	switch strings.ToLower(fields[0]) {
	case "create":
		if len(fields) < 3 {
			return slack.Msg{
				ResponseType: slack.ResponseTypeEphemeral,
				Blocks: slack.Blocks{
					BlockSet: []slack.Block{
						slack.NewHeaderBlock(
							slack.NewTextBlockObject("plain_text", "Create Rotation Help", false, false),
						),
						slack.NewSectionBlock(
							slack.NewTextBlockObject("mrkdwn", "*Usage:* `/rotation create <label> <frequency> [@user...]`", false, false),
							nil,
							nil,
						),
						slack.NewSectionBlock(
							slack.NewTextBlockObject("mrkdwn", "Valid frequencies: daily, weekly, biweekly, monthly.\nExample: `/rotation create devRotation weekly <@U12345678>`", false, false),
							nil,
							nil,
						),
					},
				},
			}, nil
		}

		return c.createRotation(ctx, cmd, fields[1], fields[2], fields[3:])

	case "show":
		if len(fields) < 2 {
			return slack.Msg{
				ResponseType: slack.ResponseTypeEphemeral,
				Blocks: slack.Blocks{
					BlockSet: []slack.Block{
						slack.NewHeaderBlock(
							slack.NewTextBlockObject("plain_text", "Show Rotation Help", false, false),
						),
						slack.NewSectionBlock(
							slack.NewTextBlockObject("mrkdwn", "*Usage:* `/rotation show <label>`", false, false),
							nil,
							nil,
						),
						slack.NewSectionBlock(
							slack.NewTextBlockObject("mrkdwn", "Example: `/rotation show devRotation`", false, false),
							nil,
							nil,
						),
					},
				},
			}, nil
		}

		return c.showRotation(ctx, cmd.TeamID, fields[1])

	case "next":
		if len(fields) < 2 {
			return slack.Msg{
				ResponseType: slack.ResponseTypeEphemeral,
				Blocks: slack.Blocks{
					BlockSet: []slack.Block{
						slack.NewHeaderBlock(
							slack.NewTextBlockObject("plain_text", "Next Rotation Help", false, false),
						),
						slack.NewSectionBlock(
							slack.NewTextBlockObject("mrkdwn", "*Usage:* `/rotation next <label>`", false, false),
							nil,
							nil,
						),
						slack.NewSectionBlock(
							slack.NewTextBlockObject("mrkdwn", "Advances to the next rotation member and returns the updated owner.", false, false),
							nil,
							nil,
						),
					},
				},
			}, nil
		}

		return c.nextRotation(ctx, cmd.TeamID, fields[1])

	case "add":
		if len(fields) < 3 {
			return slack.Msg{
				ResponseType: slack.ResponseTypeEphemeral,
				Blocks: slack.Blocks{
					BlockSet: []slack.Block{
						slack.NewHeaderBlock(
							slack.NewTextBlockObject("plain_text", "Add Users Help", false, false),
						),
						slack.NewSectionBlock(
							slack.NewTextBlockObject("mrkdwn", "*Usage:* `/rotation add <label> <@user...>`", false, false),
							nil,
							nil,
						),
						slack.NewSectionBlock(
							slack.NewTextBlockObject("mrkdwn", "Adds one or more users to the rotation.\nExample: `/rotation add devRotation <@U12345678> <@U87654321>`", false, false),
							nil,
							nil,
						),
					},
				},
			}, nil
		}

		return c.modifyRotationMembers(ctx, cmd.TeamID, fields[1], fields[2:], "add")

	case "remove":
		if len(fields) < 3 {
			return slack.Msg{
				ResponseType: slack.ResponseTypeEphemeral,
				Blocks: slack.Blocks{
					BlockSet: []slack.Block{
						slack.NewHeaderBlock(
							slack.NewTextBlockObject("plain_text", "Remove Users Help", false, false),
						),
						slack.NewSectionBlock(
							slack.NewTextBlockObject("mrkdwn", "*Usage:* `/rotation remove <label> <@user...>`", false, false),
							nil,
							nil,
						),
						slack.NewSectionBlock(
							slack.NewTextBlockObject("mrkdwn", "Removes one or more users from the rotation.\nExample: `/rotation remove devRotation <@U12345678>`", false, false),
							nil,
							nil,
						),
					},
				},
			}, nil
		}

		return c.modifyRotationMembers(ctx, cmd.TeamID, fields[1], fields[2:], "remove")

	case "move":
		if len(fields) != 4 {
			return slack.Msg{
				ResponseType: slack.ResponseTypeEphemeral,
				Blocks: slack.Blocks{
					BlockSet: []slack.Block{
						slack.NewHeaderBlock(
							slack.NewTextBlockObject("plain_text", "Move User Help", false, false),
						),
						slack.NewSectionBlock(
							slack.NewTextBlockObject("mrkdwn", "*Usage:* `/rotation move <label> <@user> <position>`", false, false),
							nil,
							nil,
						),
						slack.NewSectionBlock(
							slack.NewTextBlockObject("mrkdwn", "Moves the specified user to a new position (0-indexed).\nExample: `/rotation move devRotation <@U12345678> 0`", false, false),
							nil,
							nil,
						),
					},
				},
			}, nil
		}

		return c.moveRotationMember(ctx, cmd.TeamID, fields[1], fields[2], fields[3])

	case "reorder":
		if len(fields) < 3 {
			return slack.Msg{
				ResponseType: slack.ResponseTypeEphemeral,
				Blocks: slack.Blocks{
					BlockSet: []slack.Block{
						slack.NewHeaderBlock(
							slack.NewTextBlockObject("plain_text", "Reorder Rotation Help", false, false),
						),
						slack.NewSectionBlock(
							slack.NewTextBlockObject("mrkdwn", "*Usage:* `/rotation reorder <label> <@user...>`", false, false),
							nil,
							nil,
						),
						slack.NewSectionBlock(
							slack.NewTextBlockObject("mrkdwn", "Reorders the entire rotation. You must provide all current members in the new order.\nExample: `/rotation reorder devRotation <@U12345678> <@U87654321>`", false, false),
							nil,
							nil,
						),
					},
				},
			}, nil
		}

		return c.reorderRotation(ctx, cmd.TeamID, fields[1], fields[2:])

	case "setfrequency":
		if len(fields) != 3 {
			return slack.Msg{
				ResponseType: slack.ResponseTypeEphemeral,
				Blocks: slack.Blocks{
					BlockSet: []slack.Block{
						slack.NewHeaderBlock(
							slack.NewTextBlockObject("plain_text", "Set Frequency Help", false, false),
						),
						slack.NewSectionBlock(
							slack.NewTextBlockObject("mrkdwn", "*Usage:* `/rotation setfrequency <label> <frequency>`", false, false),
							nil,
							nil,
						),
						slack.NewSectionBlock(
							slack.NewTextBlockObject("mrkdwn", "Frequency options: daily, weekly, biweekly, monthly.\nExample: `/rotation setfrequency devRotation weekly`", false, false),
							nil,
							nil,
						),
					},
				},
			}, nil
		}

		return c.setFrequency(ctx, cmd.TeamID, fields[1], fields[2])

	case "setowner":
		if len(fields) != 3 {
			return slack.Msg{
				ResponseType: slack.ResponseTypeEphemeral,
				Blocks: slack.Blocks{
					BlockSet: []slack.Block{
						slack.NewHeaderBlock(
							slack.NewTextBlockObject("plain_text", "Set Owner Help", false, false),
						),
						slack.NewSectionBlock(
							slack.NewTextBlockObject("mrkdwn", "*Usage:* `/rotation setowner <label> <@user>`", false, false),
							nil,
							nil,
						),
						slack.NewSectionBlock(
							slack.NewTextBlockObject("mrkdwn", "Assigns the given user as the new owner of the rotation.\nExample: `/rotation setowner devRotation <@U12345678>`", false, false),
							nil,
							nil,
						),
					},
				},
			}, nil
		}

		return c.setOwner(ctx, cmd.TeamID, fields[1], fields[2])

	case "list":
		if len(fields) != 1 {
			return slack.Msg{
				ResponseType: slack.ResponseTypeEphemeral,
				Text:         "*Usage:* `/rotation list`",
			}, nil
		}

		// Use a reasonable limit (e.g., 100). For now, we don't handle a pagination token from the caller.
		rotations, _, err := c.repo.ListRotations(ctx, cmd.TeamID, 100, nil)
		if err != nil {
			return slack.Msg{}, err
		}

		if len(rotations) == 0 {
			return slack.Msg{ResponseType: slack.ResponseTypeInChannel, Text: "No rotations found."}, nil
		}

		text := "*Team Rotations:*\n"
		for _, r := range rotations {
			text += fmt.Sprintf("• `%s`: current owner <@%s>\n", r.RotationLabel, r.CurrentOwner)
		}

		return slack.Msg{ResponseType: slack.ResponseTypeInChannel, Text: text}, nil

	default:
		return slack.Msg{ResponseType: slack.ResponseTypeEphemeral, Text: "Invalid rotation command."}, nil
	}
}

// Implementations of helper functions:

func (c *RotationCommand) createRotation(ctx context.Context, cmd slack.SlashCommand, label, frequency string, users []string) (slack.Msg, error) {
	user, err := c.slackClient.GetUserInfo(cmd.UserID)

	if err != nil {
		return slack.Msg{}, err
	}

	if len(users) == 0 {
		users = []string{cmd.UserID}
	}

	rotation := repository.Rotation{
		CreatorTeamID:    cmd.TeamID,
		RotationLabel:    label,
		Frequency:        frequency,
		CurrentOwner:     users[0],
		RotationOrder:    users,
		LastRotationDate: time.Now(),
		NextRotationDate: calculateNextRotationDate(time.Now(), frequency),
		CreatorUserID:    cmd.UserID,
		CreatorUserName:  user.Name,
	}

	if err := c.repo.UpsertRotation(ctx, rotation); err != nil {
		return slack.Msg{}, err
	}

	return slack.Msg{ResponseType: slack.ResponseTypeInChannel, Text: fmt.Sprintf("Rotation `%s` created.", label)}, nil
}

func (c *RotationCommand) showRotation(ctx context.Context, teamID, label string) (slack.Msg, error) {
	r, err := c.repo.GetRotation(ctx, teamID, label)

	if err != nil || r == nil {
		return slack.Msg{}, fmt.Errorf("Rotation `%s` not found", label)
	}

	return slack.Msg{ResponseType: slack.ResponseTypeInChannel,
		Text: fmt.Sprintf("Rotation `%s`: current owner <@%s>, next <@%s>", label, r.CurrentOwner, nextOwner(r))}, nil
}

func (c *RotationCommand) nextRotation(ctx context.Context, teamID, label string) (slack.Msg, error) {
	r, err := c.repo.GetRotation(ctx, teamID, label)

	if err != nil || r == nil {
		return slack.Msg{}, fmt.Errorf("Rotation `%s` not found", label)
	}

	return slack.Msg{ResponseType: slack.ResponseTypeInChannel,
		Text: fmt.Sprintf("Next owner for `%s` is <@%s>.", label, nextOwner(r))}, nil
}

func (c *RotationCommand) modifyRotationMembers(ctx context.Context, teamID, label string, userMentions []string, action string) (slack.Msg, error) {
	r, err := c.repo.GetRotation(ctx, teamID, label)

	if err != nil || r == nil {
		return slack.Msg{}, fmt.Errorf("Rotation `%s` not found", label)
	}

	if action == "add" {
		for _, u := range userMentions {
			userID, err := extractUserIDFromMention(u)

			if err != nil {
				return slack.Msg{ //nolint:nilerr
					ResponseType: slack.ResponseTypeEphemeral,
					Text:         fmt.Sprintf("Invalid user mention: %s", u),
				}, nil
			}

			if !contains(r.RotationOrder, userID) {
				r.RotationOrder = append(r.RotationOrder, userID)
			}
		}
	} else {
		filtered := []string{}

		for _, member := range r.RotationOrder {
			if !contains(userMentions, member) {
				filtered = append(filtered, member)
			}
		}

		r.RotationOrder = filtered
	}

	if err := c.repo.UpsertRotation(ctx, *r); err != nil {
		return slack.Msg{}, err
	}

	return slack.Msg{ResponseType: slack.ResponseTypeInChannel,
		Text: fmt.Sprintf("Rotation `%s` members updated.", label)}, nil
}

func (c *RotationCommand) moveRotationMember(ctx context.Context, teamID, label, user, posStr string) (slack.Msg, error) {
	userID, err := extractUserIDFromMention(user)

	if err != nil {
		return slack.Msg{ //nolint:nilerr
			ResponseType: slack.ResponseTypeEphemeral,
			Text:         fmt.Sprintf("Invalid user mention: %s", user),
		}, nil
	}

	user = userID

	pos, err := strconv.Atoi(posStr)

	if err != nil {
		return slack.Msg{}, err
	}

	r, err := c.repo.GetRotation(ctx, teamID, label)
	if err != nil || r == nil {
		return slack.Msg{}, fmt.Errorf("Rotation `%s` not found", label)
	}

	r.RotationOrder = remove(r.RotationOrder, user)
	if pos > len(r.RotationOrder) {
		pos = len(r.RotationOrder)
	}

	r.RotationOrder = append(r.RotationOrder[:pos], append([]string{user}, r.RotationOrder[pos:]...)...)

	return slack.Msg{ResponseType: slack.ResponseTypeInChannel, Text: fmt.Sprintf("Moved <@%s> in rotation `%s`.", user, label)}, c.repo.UpsertRotation(ctx, *r)
}

// reorderRotation reorders the rotation members based on the provided user list.
func (c *RotationCommand) reorderRotation(ctx context.Context, teamID, label string, users []string) (slack.Msg, error) {
	r, err := c.repo.GetRotation(ctx, teamID, label)

	if err != nil || r == nil {
		return slack.Msg{}, fmt.Errorf("Rotation `%s` not found", label)
	}

	if len(users) != len(r.RotationOrder) {
		return slack.Msg{}, fmt.Errorf("provided user list must include all current rotation members")
	}

	for _, user := range users {
		if !contains(r.RotationOrder, user) {
			return slack.Msg{}, fmt.Errorf("user %s is not in the current rotation", user)
		}
	}

	r.RotationOrder = users
	// Ensure current owner remains valid.
	if !contains(users, r.CurrentOwner) {
		r.CurrentOwner = users[0]
	}

	if err := c.repo.UpsertRotation(ctx, *r); err != nil {
		return slack.Msg{}, err
	}

	return slack.Msg{ResponseType: slack.ResponseTypeInChannel,
		Text: fmt.Sprintf("Rotation `%s` reordered.", label)}, nil
}

// setFrequency sets a new frequency for the rotation and recalculates the next rotation date.
func (c *RotationCommand) setFrequency(ctx context.Context, teamID, label, frequency string) (slack.Msg, error) {
	r, err := c.repo.GetRotation(ctx, teamID, label)

	if err != nil || r == nil {
		return slack.Msg{}, fmt.Errorf("Rotation `%s` not found", label)
	}

	r.Frequency = frequency
	r.NextRotationDate = calculateNextRotationDate(r.LastRotationDate, frequency)

	if err := c.repo.UpsertRotation(ctx, *r); err != nil {
		return slack.Msg{}, err
	}

	return slack.Msg{ResponseType: slack.ResponseTypeInChannel,
		Text: fmt.Sprintf("Frequency for rotation `%s` set to `%s`.", label, frequency)}, nil
}

// setOwner sets the current owner of the rotation.
func (c *RotationCommand) setOwner(ctx context.Context, teamID, label, userMention string) (slack.Msg, error) {
	// Extract the user ID from the mention
	userID, err := extractUserIDFromMention(userMention)

	if err != nil {
		return slack.Msg{ //nolint:nilerr
			ResponseType: slack.ResponseTypeEphemeral,
			Text:         fmt.Sprintf("Invalid user mention: %s", userMention),
		}, nil
	}

	r, err := c.repo.GetRotation(ctx, teamID, label)

	if err != nil || r == nil {
		return slack.Msg{}, fmt.Errorf("Rotation `%s` not found", label)
	}

	if !contains(r.RotationOrder, userID) {
		return slack.Msg{}, fmt.Errorf("User <@%s> is not a member of rotation `%s`", userID, label)
	}

	r.CurrentOwner = userID
	r.NextRotationDate = calculateNextRotationDate(r.LastRotationDate, r.Frequency)

	if err := c.repo.UpsertRotation(ctx, *r); err != nil {
		return slack.Msg{}, err
	}

	return slack.Msg{ResponseType: slack.ResponseTypeInChannel,
		Text: fmt.Sprintf("Current owner for rotation `%s` set to <@%s>.", label, userID)}, nil
}

// Helper functions
func contains(slice []string, s string) bool {
	for _, item := range slice {
		if item == s {
			return true
		}
	}

	return false
}

func remove(slice []string, s string) []string {
	filtered := []string{}

	for _, item := range slice {
		if item != s {
			filtered = append(filtered, item)
		}
	}

	return filtered
}

func calculateNextRotationDate(lastDate time.Time, frequency string) time.Time {
	switch frequency {
	case "daily":
		return lastDate.AddDate(0, 0, 1)

	case "weekly":
		return lastDate.AddDate(0, 0, 7)

	case "biweekly":
		return lastDate.AddDate(0, 0, 14)

	case "monthly":
		return lastDate.AddDate(0, 1, 0)

	default:
		return lastDate.AddDate(0, 0, 7)
	}
}

func nextOwner(r *repository.Rotation) string {
	for i, owner := range r.RotationOrder {
		if owner == r.CurrentOwner {
			return r.RotationOrder[(i+1)%len(r.RotationOrder)]
		}
	}

	return r.RotationOrder[0]
}

// extractUserIDFromMention parses the Slack mention format and returns the user ID.
func extractUserIDFromMention(mention string) (string, error) {
	// Regular expression to match both <@USER_ID|username> and <@USER_ID> patterns
	re := regexp.MustCompile(`<@([UW][A-Z0-9]{8,})(?:\|[^>]+)?>`)

	match := re.FindStringSubmatch(mention)

	if len(match) != 2 {
		return "", fmt.Errorf("invalid mention format: %s", mention)
	}

	return match[1], nil
}
