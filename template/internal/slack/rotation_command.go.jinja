package slack
 
import (
	"context"
	"fmt"
	"sort"
	"strings"

	"github.com/rs/zerolog"
	"github.com/samber/lo"
	"github.com/slack-go/slack"

	"{{ github_path }}/internal/slack/commands"
	"{{ github_path }}/internal/tick"
	"{{ github_path }}/internal/repository"
)

// RotationSubCommand defines the interface for all rotation subcommands
//
// To implement a new rotation subcommand:
//   1. Create a new file in the commands directory.
//   2. Define a type that implements this interface:
//      - Name() string      // returns the command string (e.g., "mycommand")
//      - HelpBlocks() []slack.Block  // returns usage instructions
//      - Execute(ctx, cmd, args) (slack.Msg, error)  // contains the command logic
//   3. Register your command in RotationCommand.registerSubCommands.
type RotationSubCommand interface {
	// Name returns the command name (e.g., "create", "show", "list", etc.)
	Name() string

	// Execute runs the command with provided arguments
	Execute(ctx context.Context, cmd slack.SlashCommand, args []string) (slack.Msg, error)

	// HelpBlocks returns help blocks for the usage information of this command
	HelpBlocks() []slack.Block
}

// RotationCommand handles rotation-related commands.
type RotationCommand struct {
	repo          repository.RotationRepository
	slackClient   *slack.Client // used for querying user info
	tickProcessor tick.Processor
	logger        zerolog.Logger
	
	// Registry of subcommands indexed by command name
	commands map[string]RotationSubCommand
}

var _ SlackCommandHandler = (*RotationCommand)(nil)

func NewRotationCommand(repo repository.RotationRepository, slackClient *slack.Client, tickProcessor tick.Processor, logger zerolog.Logger) *RotationCommand {
	cmd := &RotationCommand{
		repo:          repo,
		slackClient:   slackClient,
		tickProcessor: tickProcessor,
		logger:        logger,
		commands:      make(map[string]RotationSubCommand),
	}
	
	// Register all subcommands
	cmd.registerSubCommands()
	
	return cmd
}

// registerSubCommands initializes and registers all subcommands
func (c *RotationCommand) registerSubCommands() {
	subCommands := []RotationSubCommand{
		commands.NewCreateCommand(c.repo, c.slackClient),
		commands.NewShowCommand(c.repo),
		commands.NewNextCommand(c.repo),
		commands.NewAddCommand(c.repo),
		commands.NewRemoveCommand(c.repo),
		commands.NewMoveCommand(c.repo),
		commands.NewReorderCommand(c.repo),
		commands.NewSetFrequencyCommand(c.repo),
		commands.NewSetOwnerCommand(c.repo, c.slackClient),
		commands.NewListCommand(c.repo),
		commands.NewSetChannelCommand(c.repo),
		commands.NewTickCommand(c.tickProcessor, c.logger), // NEW: Added TickCommand subcommand.
		commands.NewStartCommand(c.repo), // NEW: Added Start command to set rotation start
	}
	
	for _, cmd := range subCommands {
		c.commands[cmd.Name()] = cmd
	}
}

func (c *RotationCommand) HandleCommand(ctx context.Context, cmd slack.SlashCommand) (slack.Msg, error) {
	args := strings.Fields(strings.TrimSpace(cmd.Text))

	if len(args) == 0 {
		// Show general help with all available commands
		blocks := []slack.Block{
			slack.NewHeaderBlock(
				slack.NewTextBlockObject("plain_text", "Usage Instructions", false, false),
			),
			slack.NewSectionBlock(
				slack.NewTextBlockObject("mrkdwn", "*Usage:* `/rotation <command> [parameters]`", false, false),
				nil,
				nil,
			),
			slack.NewDividerBlock(),
			slack.NewSectionBlock(
				slack.NewTextBlockObject("mrkdwn", "*Available Commands:*", false, false),
				nil,
				nil,
			),
		}

		// Build command list text
		cmds := lo.Keys(c.commands)
		sort.Strings(cmds)
		var cmdList string
		for _, name := range cmds {
			cmdList += fmt.Sprintf("â€¢ `%s`\n", name)
		}
		
		blocks = append(blocks, 
			slack.NewSectionBlock(
				slack.NewTextBlockObject("mrkdwn", cmdList, false, false),
				nil,
				nil,
			),
			slack.NewDividerBlock(),
			slack.NewSectionBlock(
				slack.NewTextBlockObject("mrkdwn", "For more details on each command, use `/rotation help <command>` or run the command without parameters.", false, false),
				nil,
				nil,
			),
		)

		return slack.Msg{
			ResponseType: slack.ResponseTypeEphemeral,
			Blocks: slack.Blocks{BlockSet: blocks},
		}, nil
	}

	// Check if this is a help request for a specific command
	if strings.ToLower(args[0]) == "help" && len(args) > 1 {
		cmdName := strings.ToLower(args[1])
		if subCmd, ok := c.commands[cmdName]; ok {
			return slack.Msg{
				ResponseType: slack.ResponseTypeEphemeral,
				Blocks: slack.Blocks{BlockSet: subCmd.HelpBlocks()},
			}, nil
		}
		return slack.Msg{ResponseType: slack.ResponseTypeEphemeral, Text: "Unknown command: " + cmdName}, nil
	}

	// Execute the requested command
	cmdName := strings.ToLower(args[0])
	if subCmd, ok := c.commands[cmdName]; ok {
		return subCmd.Execute(ctx, cmd, args[1:])
	}

	return slack.Msg{ResponseType: slack.ResponseTypeEphemeral, Text: "Invalid rotation command."}, nil
}

// (The command implementations were moved to individual files under /commands)
