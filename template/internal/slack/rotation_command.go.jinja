package slack
 
import (
	"context"
	"fmt"
	"regexp"
	"sort"
	"strconv"
	"strings"
	"time"

	"github.com/rs/zerolog"
	"github.com/samber/lo"
	"github.com/slack-go/slack"

	"{{ github_path }}/internal/tick"
	"{{ github_path }}/internal/repository"
)

// RotationSubCommand defines the interface for all rotation subcommands
type RotationSubCommand interface {
	// Name returns the command name (e.g., "create", "show", "list", etc.)
	Name() string

	// Execute runs the command with provided arguments
	Execute(ctx context.Context, cmd slack.SlashCommand, args []string) (slack.Msg, error)

	// HelpBlocks returns help blocks for the usage information of this command
	HelpBlocks() []slack.Block
}

// RotationCommand handles rotation-related commands.
type RotationCommand struct {
	repo          repository.RotationRepository
	slackClient   *slack.Client // used for querying user info
	tickProcessor tick.Processor
	logger        zerolog.Logger
	
	// Registry of subcommands indexed by command name
	commands map[string]RotationSubCommand
}

var _ SlackCommandHandler = (*RotationCommand)(nil)

func NewRotationCommand(repo repository.RotationRepository, slackClient *slack.Client, tickProcessor tick.Processor, logger zerolog.Logger) *RotationCommand {
	cmd := &RotationCommand{
		repo:          repo,
		slackClient:   slackClient,
		tickProcessor: tickProcessor,
		logger:        logger,
		commands:      make(map[string]RotationSubCommand),
	}
	
	// Register all subcommands
	cmd.registerSubCommands()
	
	return cmd
}

// registerSubCommands initializes and registers all subcommands
func (c *RotationCommand) registerSubCommands() {
	subCommands := []RotationSubCommand{
		NewCreateCommand(c.repo, c.slackClient),
		NewShowCommand(c.repo),
		NewNextCommand(c.repo),
		NewAddCommand(c.repo),
		NewRemoveCommand(c.repo),
		NewMoveCommand(c.repo),
		NewReorderCommand(c.repo),
		NewSetFrequencyCommand(c.repo),
		NewSetOwnerCommand(c.repo, c.slackClient),
		NewListCommand(c.repo),
		NewSetChannelCommand(c.repo),
		NewTickCommand(c.tickProcessor, c.logger), // NEW: Added TickCommand subcommand.
		NewStartCommand(c.repo), // NEW: Added Start command to set rotation start
	}
	
	for _, cmd := range subCommands {
		c.commands[cmd.Name()] = cmd
	}
}

func (c *RotationCommand) HandleCommand(ctx context.Context, cmd slack.SlashCommand) (slack.Msg, error) {
	args := strings.Fields(strings.TrimSpace(cmd.Text))

	if len(args) == 0 {
		// Show general help with all available commands
		blocks := []slack.Block{
			slack.NewHeaderBlock(
				slack.NewTextBlockObject("plain_text", "Usage Instructions", false, false),
			),
			slack.NewSectionBlock(
				slack.NewTextBlockObject("mrkdwn", "*Usage:* `/rotation <command> [parameters]`", false, false),
				nil,
				nil,
			),
			slack.NewDividerBlock(),
			slack.NewSectionBlock(
				slack.NewTextBlockObject("mrkdwn", "*Available Commands:*", false, false),
				nil,
				nil,
			),
		}

		// Build command list text
		cmds := lo.Keys(c.commands)
		sort.Strings(cmds)
		var cmdList string
		for _, name := range cmds {
			cmdList += fmt.Sprintf("• `%s`\n", name)
		}
		
		blocks = append(blocks, 
			slack.NewSectionBlock(
				slack.NewTextBlockObject("mrkdwn", cmdList, false, false),
				nil,
				nil,
			),
			slack.NewDividerBlock(),
			slack.NewSectionBlock(
				slack.NewTextBlockObject("mrkdwn", "For more details on each command, use `/rotation help <command>` or run the command without parameters.", false, false),
				nil,
				nil,
			),
		)

		return slack.Msg{
			ResponseType: slack.ResponseTypeEphemeral,
			Blocks: slack.Blocks{BlockSet: blocks},
		}, nil
	}

	// Check if this is a help request for a specific command
	if strings.ToLower(args[0]) == "help" && len(args) > 1 {
		cmdName := strings.ToLower(args[1])
		if subCmd, ok := c.commands[cmdName]; ok {
			return slack.Msg{
				ResponseType: slack.ResponseTypeEphemeral,
				Blocks: slack.Blocks{BlockSet: subCmd.HelpBlocks()},
			}, nil
		}
		return slack.Msg{ResponseType: slack.ResponseTypeEphemeral, Text: "Unknown command: " + cmdName}, nil
	}

	// Execute the requested command
	cmdName := strings.ToLower(args[0])
	if subCmd, ok := c.commands[cmdName]; ok {
		return subCmd.Execute(ctx, cmd, args[1:])
	}

	return slack.Msg{ResponseType: slack.ResponseTypeEphemeral, Text: "Invalid rotation command."}, nil
}

// Individual command implementations

// CreateCommand handles the "create" subcommand
type CreateCommand struct {
	repo        repository.RotationRepository
	slackClient *slack.Client
}

func NewCreateCommand(repo repository.RotationRepository, slackClient *slack.Client) *CreateCommand {
	return &CreateCommand{
		repo:        repo,
		slackClient: slackClient,
	}
}

func (c *CreateCommand) Name() string {
	return "create"
}

func (c *CreateCommand) HelpBlocks() []slack.Block {
	return []slack.Block{
		slack.NewHeaderBlock(
			slack.NewTextBlockObject("plain_text", "Create Rotation Help", false, false),
		),
		slack.NewSectionBlock(
			slack.NewTextBlockObject("mrkdwn", "*Usage:* `/rotation create <label> <frequency> [@user...]`", false, false),
			nil,
			nil,
		),
		slack.NewSectionBlock(
			slack.NewTextBlockObject("mrkdwn", "Valid frequencies: daily, weekly, biweekly, monthly.\nExample: `/rotation create devRotation weekly <@U12345678>`", false, false),
			nil,
			nil,
		),
	}
}

func (c *CreateCommand) Execute(ctx context.Context, cmd slack.SlashCommand, args []string) (slack.Msg, error) {
	if len(args) < 2 {
		return slack.Msg{
			ResponseType: slack.ResponseTypeEphemeral,
			Blocks:       slack.Blocks{BlockSet: c.HelpBlocks()},
		}, nil
	}
	
	label := args[0]
	frequency := args[1]
	var users []string
	if len(args) > 2 {
		users = args[2:]
	}
	
	return c.createRotation(ctx, cmd, label, frequency, users)
}

func (c *CreateCommand) createRotation(ctx context.Context, cmd slack.SlashCommand, label, frequency string, users []string) (slack.Msg, error) {
	user, err := c.slackClient.GetUserInfo(cmd.UserID)

	if err != nil {
		return slack.Msg{}, err
	}

	if len(users) == 0 {
		users = []string{cmd.UserID}
	}

	rotation := repository.Rotation{
		CreatorTeamID:    cmd.TeamID,
		RotationLabel:    label,
		Frequency:        frequency,
		CurrentOwner:     users[0],
		RotationOrder:    users,
		LastRotationDate: time.Now(),
		NextRotationDate: calculateNextRotationDate(time.Now(), frequency),
		CreatorUserID:    cmd.UserID,
		CreatorUserName:  user.Name,
	}

	if err := c.repo.UpsertRotation(ctx, rotation); err != nil {
		return slack.Msg{}, err
	}

	return slack.Msg{ResponseType: slack.ResponseTypeInChannel, Text: fmt.Sprintf("Rotation `%s` created.", label)}, nil
}

// ShowCommand handles the "show" subcommand
type ShowCommand struct {
	repo repository.RotationRepository
}

func NewShowCommand(repo repository.RotationRepository) *ShowCommand {
	return &ShowCommand{
		repo: repo,
	}
}

func (c *ShowCommand) Name() string {
	return "show"
}

func (c *ShowCommand) HelpBlocks() []slack.Block {
	return []slack.Block{
		slack.NewHeaderBlock(
			slack.NewTextBlockObject("plain_text", "Show Rotation Help", false, false),
		),
		slack.NewSectionBlock(
			slack.NewTextBlockObject("mrkdwn", "*Usage:* `/rotation show <label>`", false, false),
			nil,
			nil,
		),
		slack.NewSectionBlock(
			slack.NewTextBlockObject("mrkdwn", "Example: `/rotation show devRotation`", false, false),
			nil,
			nil,
		),
	}
}

func (c *ShowCommand) Execute(ctx context.Context, cmd slack.SlashCommand, args []string) (slack.Msg, error) {
	if len(args) < 1 {
		return slack.Msg{
			ResponseType: slack.ResponseTypeEphemeral,
			Blocks:       slack.Blocks{BlockSet: c.HelpBlocks()},
		}, nil
	}
	
	return c.showRotation(ctx, cmd.TeamID, args[0])
}

func (c *ShowCommand) showRotation(ctx context.Context, teamID, label string) (slack.Msg, error) {
	r, err := c.repo.GetRotation(ctx, teamID, label)

	if err != nil || r == nil {
		return slack.Msg{}, fmt.Errorf("Rotation `%s` not found", label)
	}

	return slack.Msg{ResponseType: slack.ResponseTypeInChannel,
		Text: fmt.Sprintf("Rotation `%s`: current owner <@%s>, next <@%s>", label, r.CurrentOwner, nextOwner(r))}, nil
}

// NextCommand handles the "next" subcommand
type NextCommand struct {
	repo repository.RotationRepository
}

func NewNextCommand(repo repository.RotationRepository) *NextCommand {
	return &NextCommand{
		repo: repo,
	}
}

func (c *NextCommand) Name() string {
	return "next"
}

func (c *NextCommand) HelpBlocks() []slack.Block {
	return []slack.Block{
		slack.NewHeaderBlock(
			slack.NewTextBlockObject("plain_text", "Next Rotation Help", false, false),
		),
		slack.NewSectionBlock(
			slack.NewTextBlockObject("mrkdwn", "*Usage:* `/rotation next <label>`", false, false),
			nil,
			nil,
		),
		slack.NewSectionBlock(
			slack.NewTextBlockObject("mrkdwn", "Advances to the next rotation member and returns the updated owner.", false, false),
			nil,
			nil,
		),
	}
}

func (c *NextCommand) Execute(ctx context.Context, cmd slack.SlashCommand, args []string) (slack.Msg, error) {
	if len(args) < 1 {
		return slack.Msg{
			ResponseType: slack.ResponseTypeEphemeral,
			Blocks:       slack.Blocks{BlockSet: c.HelpBlocks()},
		}, nil
	}
	
	return c.nextRotation(ctx, cmd.TeamID, args[0])
}

func (c *NextCommand) nextRotation(ctx context.Context, teamID, label string) (slack.Msg, error) {
	r, err := c.repo.GetRotation(ctx, teamID, label)

	if err != nil || r == nil {
		return slack.Msg{}, fmt.Errorf("Rotation `%s` not found", label)
	}

	return slack.Msg{ResponseType: slack.ResponseTypeInChannel,
		Text: fmt.Sprintf("Next owner for `%s` is <@%s>.", label, nextOwner(r))}, nil
}

// AddCommand handles the "add" subcommand
type AddCommand struct {
	repo repository.RotationRepository
}

func NewAddCommand(repo repository.RotationRepository) *AddCommand {
	return &AddCommand{
		repo: repo,
	}
}

func (c *AddCommand) Name() string {
	return "add"
}

func (c *AddCommand) HelpBlocks() []slack.Block {
	return []slack.Block{
		slack.NewHeaderBlock(
			slack.NewTextBlockObject("plain_text", "Add Users Help", false, false),
		),
		slack.NewSectionBlock(
			slack.NewTextBlockObject("mrkdwn", "*Usage:* `/rotation add <label> <@user...>`", false, false),
			nil,
			nil,
		),
		slack.NewSectionBlock(
			slack.NewTextBlockObject("mrkdwn", "Adds one or more users to the rotation.\nExample: `/rotation add devRotation <@U12345678> <@U87654321>`", false, false),
			nil,
			nil,
		),
	}
}

func (c *AddCommand) Execute(ctx context.Context, cmd slack.SlashCommand, args []string) (slack.Msg, error) {
	if len(args) < 2 {
		return slack.Msg{
			ResponseType: slack.ResponseTypeEphemeral,
			Blocks:       slack.Blocks{BlockSet: c.HelpBlocks()},
		}, nil
	}
	
	return c.modifyRotationMembers(ctx, cmd.TeamID, args[0], args[1:], "add")
}

// RemoveCommand handles the "remove" subcommand
type RemoveCommand struct {
	repo repository.RotationRepository
}

func NewRemoveCommand(repo repository.RotationRepository) *RemoveCommand {
	return &RemoveCommand{
		repo: repo,
	}
}

func (c *RemoveCommand) Name() string {
	return "remove"
}

func (c *RemoveCommand) HelpBlocks() []slack.Block {
	return []slack.Block{
		slack.NewHeaderBlock(
			slack.NewTextBlockObject("plain_text", "Remove Users Help", false, false),
		),
		slack.NewSectionBlock(
			slack.NewTextBlockObject("mrkdwn", "*Usage:* `/rotation remove <label> <@user...>`", false, false),
			nil,
			nil,
		),
		slack.NewSectionBlock(
			slack.NewTextBlockObject("mrkdwn", "Removes one or more users from the rotation.\nExample: `/rotation remove devRotation <@U12345678>`", false, false),
			nil,
			nil,
		),
	}
}

func (c *RemoveCommand) Execute(ctx context.Context, cmd slack.SlashCommand, args []string) (slack.Msg, error) {
	if len(args) < 2 {
		return slack.Msg{
			ResponseType: slack.ResponseTypeEphemeral,
			Blocks:       slack.Blocks{BlockSet: c.HelpBlocks()},
		}, nil
	}
	
	return c.modifyRotationMembers(ctx, cmd.TeamID, args[0], args[1:], "remove")
}

// modifyRotationMembers is a shared implementation for add and remove commands
func (c *AddCommand) modifyRotationMembers(ctx context.Context, teamID, label string, userMentions []string, action string) (slack.Msg, error) {
	r, err := c.repo.GetRotation(ctx, teamID, label)

	if err != nil || r == nil {
		return slack.Msg{}, fmt.Errorf("Rotation `%s` not found", label)
	}

	if action == "add" {
		for _, u := range userMentions {
			userID, err := extractUserIDFromMention(u)

			if err != nil {
				return slack.Msg{ //nolint:nilerr
					ResponseType: slack.ResponseTypeEphemeral,
					Text:         fmt.Sprintf("Invalid user mention: %s", u),
				}, nil
			}

			if !contains(r.RotationOrder, userID) {
				r.RotationOrder = append(r.RotationOrder, userID)
			}
		}
	} else {
		filtered := []string{}

		for _, member := range r.RotationOrder {
			if !contains(userMentions, member) {
				filtered = append(filtered, member)
			}
		}

		r.RotationOrder = filtered
	}

	if err := c.repo.UpsertRotation(ctx, *r); err != nil {
		return slack.Msg{}, err
	}

	return slack.Msg{ResponseType: slack.ResponseTypeInChannel,
		Text: fmt.Sprintf("Rotation `%s` members updated.", label)}, nil
}

// modifyRotationMembers is a shared implementation for add and remove commands
func (c *RemoveCommand) modifyRotationMembers(ctx context.Context, teamID, label string, userMentions []string, action string) (slack.Msg, error) {
	r, err := c.repo.GetRotation(ctx, teamID, label)

	if err != nil || r == nil {
		return slack.Msg{}, fmt.Errorf("Rotation `%s` not found", label)
	}

	if action == "add" {
		for _, u := range userMentions {
			userID, err := extractUserIDFromMention(u)

			if err != nil {
				return slack.Msg{ //nolint:nilerr
					ResponseType: slack.ResponseTypeEphemeral,
					Text:         fmt.Sprintf("Invalid user mention: %s", u),
				}, nil
			}

			if !contains(r.RotationOrder, userID) {
				r.RotationOrder = append(r.RotationOrder, userID)
			}
		}
	} else {
		filtered := []string{}

		for _, member := range r.RotationOrder {
			if !contains(userMentions, member) {
				filtered = append(filtered, member)
			}
		}

		r.RotationOrder = filtered
	}

	if err := c.repo.UpsertRotation(ctx, *r); err != nil {
		return slack.Msg{}, err
	}

	return slack.Msg{ResponseType: slack.ResponseTypeInChannel,
		Text: fmt.Sprintf("Rotation `%s` members updated.", label)}, nil
}

// MoveCommand handles the "move" subcommand
type MoveCommand struct {
	repo repository.RotationRepository
}

func NewMoveCommand(repo repository.RotationRepository) *MoveCommand {
	return &MoveCommand{
		repo: repo,
	}
}

func (c *MoveCommand) Name() string {
	return "move"
}

func (c *MoveCommand) HelpBlocks() []slack.Block {
	return []slack.Block{
		slack.NewHeaderBlock(
			slack.NewTextBlockObject("plain_text", "Move User Help", false, false),
		),
		slack.NewSectionBlock(
			slack.NewTextBlockObject("mrkdwn", "*Usage:* `/rotation move <label> <@user> <position>`", false, false),
			nil,
			nil,
		),
		slack.NewSectionBlock(
			slack.NewTextBlockObject("mrkdwn", "Moves the specified user to a new position (0-indexed).\nExample: `/rotation move devRotation <@U12345678> 0`", false, false),
			nil,
			nil,
		),
	}
}

func (c *MoveCommand) Execute(ctx context.Context, cmd slack.SlashCommand, args []string) (slack.Msg, error) {
	if len(args) != 3 {
		return slack.Msg{
			ResponseType: slack.ResponseTypeEphemeral,
			Blocks:       slack.Blocks{BlockSet: c.HelpBlocks()},
		}, nil
	}
	
	return c.moveRotationMember(ctx, cmd.TeamID, args[0], args[1], args[2])
}

func (c *MoveCommand) moveRotationMember(ctx context.Context, teamID, label, user, posStr string) (slack.Msg, error) {
	userID, err := extractUserIDFromMention(user)

	if err != nil {
		return slack.Msg{ //nolint:nilerr
			ResponseType: slack.ResponseTypeEphemeral,
			Text:         fmt.Sprintf("Invalid user mention: %s", user),
		}, nil
	}

	user = userID

	pos, err := strconv.Atoi(posStr)

	if err != nil {
		return slack.Msg{}, err
	}

	r, err := c.repo.GetRotation(ctx, teamID, label)
	if err != nil || r == nil {
		return slack.Msg{}, fmt.Errorf("Rotation `%s` not found", label)
	}

	r.RotationOrder = remove(r.RotationOrder, user)
	if pos > len(r.RotationOrder) {
		pos = len(r.RotationOrder)
	}

	r.RotationOrder = append(r.RotationOrder[:pos], append([]string{user}, r.RotationOrder[pos:]...)...)

	return slack.Msg{ResponseType: slack.ResponseTypeInChannel, Text: fmt.Sprintf("Moved <@%s> in rotation `%s`.", user, label)}, c.repo.UpsertRotation(ctx, *r)
}

// ReorderCommand handles the "reorder" subcommand
type ReorderCommand struct {
	repo repository.RotationRepository
}

func NewReorderCommand(repo repository.RotationRepository) *ReorderCommand {
	return &ReorderCommand{
		repo: repo,
	}
}

func (c *ReorderCommand) Name() string {
	return "reorder"
}

func (c *ReorderCommand) HelpBlocks() []slack.Block {
	return []slack.Block{
		slack.NewHeaderBlock(
			slack.NewTextBlockObject("plain_text", "Reorder Rotation Help", false, false),
		),
		slack.NewSectionBlock(
			slack.NewTextBlockObject("mrkdwn", "*Usage:* `/rotation reorder <label> <@user...>`", false, false),
			nil,
			nil,
		),
		slack.NewSectionBlock(
			slack.NewTextBlockObject("mrkdwn", "Reorders the entire rotation. You must provide all current members in the new order.\nExample: `/rotation reorder devRotation <@U12345678> <@U87654321>`", false, false),
			nil,
			nil,
		),
	}
}

func (c *ReorderCommand) Execute(ctx context.Context, cmd slack.SlashCommand, args []string) (slack.Msg, error) {
	if len(args) < 2 {
		return slack.Msg{
			ResponseType: slack.ResponseTypeEphemeral,
			Blocks:       slack.Blocks{BlockSet: c.HelpBlocks()},
		}, nil
	}
	
	return c.reorderRotation(ctx, cmd.TeamID, args[0], args[1:])
}

// reorderRotation reorders the rotation members based on the provided user list.
func (c *ReorderCommand) reorderRotation(ctx context.Context, teamID, label string, users []string) (slack.Msg, error) {
	r, err := c.repo.GetRotation(ctx, teamID, label)

	if err != nil || r == nil {
		return slack.Msg{}, fmt.Errorf("Rotation `%s` not found", label)
	}

	if len(users) != len(r.RotationOrder) {
		return slack.Msg{}, fmt.Errorf("provided user list must include all current rotation members")
	}

	for _, user := range users {
		if !contains(r.RotationOrder, user) {
			return slack.Msg{}, fmt.Errorf("user %s is not in the current rotation", user)
		}
	}

	r.RotationOrder = users
	// Ensure current owner remains valid.
	if !contains(users, r.CurrentOwner) {
		r.CurrentOwner = users[0]
	}

	if err := c.repo.UpsertRotation(ctx, *r); err != nil {
		return slack.Msg{}, err
	}

	return slack.Msg{ResponseType: slack.ResponseTypeInChannel,
		Text: fmt.Sprintf("Rotation `%s` reordered.", label)}, nil
}

// SetFrequencyCommand handles the "setfrequency" subcommand
type SetFrequencyCommand struct {
	repo repository.RotationRepository
}

func NewSetFrequencyCommand(repo repository.RotationRepository) *SetFrequencyCommand {
	return &SetFrequencyCommand{
		repo: repo,
	}
}

func (c *SetFrequencyCommand) Name() string {
	return "setfrequency"
}

func (c *SetFrequencyCommand) HelpBlocks() []slack.Block {
	return []slack.Block{
		slack.NewHeaderBlock(
			slack.NewTextBlockObject("plain_text", "Set Frequency Help", false, false),
		),
		slack.NewSectionBlock(
			slack.NewTextBlockObject("mrkdwn", "*Usage:* `/rotation setfrequency <label> <frequency>`", false, false),
			nil,
			nil,
		),
		slack.NewSectionBlock(
			slack.NewTextBlockObject("mrkdwn", "Frequency options: daily, weekly, biweekly, monthly.\nExample: `/rotation setfrequency devRotation weekly`", false, false),
			nil,
			nil,
		),
	}
}

func (c *SetFrequencyCommand) Execute(ctx context.Context, cmd slack.SlashCommand, args []string) (slack.Msg, error) {
	if len(args) != 2 {
		return slack.Msg{
			ResponseType: slack.ResponseTypeEphemeral,
			Blocks:       slack.Blocks{BlockSet: c.HelpBlocks()},
		}, nil
	}
	
	return c.setFrequency(ctx, cmd.TeamID, args[0], args[1])
}

// setFrequency sets a new frequency for the rotation and recalculates the next rotation date.
func (c *SetFrequencyCommand) setFrequency(ctx context.Context, teamID, label, frequency string) (slack.Msg, error) {
	r, err := c.repo.GetRotation(ctx, teamID, label)

	if err != nil || r == nil {
		return slack.Msg{}, fmt.Errorf("Rotation `%s` not found", label)
	}

	r.Frequency = frequency
	r.NextRotationDate = calculateNextRotationDate(r.LastRotationDate, frequency)

	if err := c.repo.UpsertRotation(ctx, *r); err != nil {
		return slack.Msg{}, err
	}

	return slack.Msg{ResponseType: slack.ResponseTypeInChannel,
		Text: fmt.Sprintf("Frequency for rotation `%s` set to `%s`.", label, frequency)}, nil
}

// SetOwnerCommand handles the "setowner" subcommand
type SetOwnerCommand struct {
	repo repository.RotationRepository
	slackClient *slack.Client
}

func NewSetOwnerCommand(repo repository.RotationRepository, slackClient *slack.Client) *SetOwnerCommand {
	return &SetOwnerCommand{
		repo: repo,
		slackClient: slackClient,
	}
}

func (c *SetOwnerCommand) Name() string {
	return "setowner"
}

func (c *SetOwnerCommand) HelpBlocks() []slack.Block {
	return []slack.Block{
		slack.NewHeaderBlock(
			slack.NewTextBlockObject("plain_text", "Set Owner Help", false, false),
		),
		slack.NewSectionBlock(
			slack.NewTextBlockObject("mrkdwn", "*Usage:* `/rotation setowner <label> <@user>`", false, false),
			nil,
			nil,
		),
		slack.NewSectionBlock(
			slack.NewTextBlockObject("mrkdwn", "Assigns the given user as the new owner of the rotation.\nExample: `/rotation setowner devRotation <@U12345678>`", false, false),
			nil,
			nil,
		),
	}
}

func (c *SetOwnerCommand) Execute(ctx context.Context, cmd slack.SlashCommand, args []string) (slack.Msg, error) {
	if len(args) != 2 {
		return slack.Msg{
			ResponseType: slack.ResponseTypeEphemeral,
			Blocks:       slack.Blocks{BlockSet: c.HelpBlocks()},
		}, nil
	}
	
	return c.setOwner(ctx, cmd.TeamID, args[0], args[1])
}

// setOwner sets the current owner of the rotation.
func (c *SetOwnerCommand) setOwner(ctx context.Context, teamID, label, userMention string) (slack.Msg, error) {
	// Extract the user ID from the mention
	userID, err := extractUserIDFromMention(userMention)

	if err != nil {
		return slack.Msg{ //nolint:nilerr
			ResponseType: slack.ResponseTypeEphemeral,
			Text:         fmt.Sprintf("Invalid user mention: %s", userMention),
		}, nil
	}

	r, err := c.repo.GetRotation(ctx, teamID, label)

	if err != nil || r == nil {
		return slack.Msg{}, fmt.Errorf("Rotation `%s` not found", label)
	}

	if !contains(r.RotationOrder, userID) {
		return slack.Msg{}, fmt.Errorf("User <@%s> is not a member of rotation `%s`", userID, label)
	}

	r.CurrentOwner = userID
	r.NextRotationDate = calculateNextRotationDate(r.LastRotationDate, r.Frequency)

	if err := c.repo.UpsertRotation(ctx, *r); err != nil {
		return slack.Msg{}, err
	}

	return slack.Msg{ResponseType: slack.ResponseTypeInChannel,
		Text: fmt.Sprintf("Current owner for rotation `%s` set to <@%s>.", label, userID)}, nil
}

// ListCommand handles the "list" subcommand
type ListCommand struct {
	repo repository.RotationRepository
}

func NewListCommand(repo repository.RotationRepository) *ListCommand {
	return &ListCommand{
		repo: repo,
	}
}

func (c *ListCommand) Name() string {
	return "list"
}

func (c *ListCommand) HelpBlocks() []slack.Block {
	return []slack.Block{
		slack.NewHeaderBlock(
			slack.NewTextBlockObject("plain_text", "List Rotations Help", false, false),
		),
		slack.NewSectionBlock(
			slack.NewTextBlockObject("mrkdwn", "*Usage:* `/rotation list`", false, false),
			nil,
			nil,
		),
		slack.NewSectionBlock(
			slack.NewTextBlockObject("mrkdwn", "Lists all rotations for the team.", false, false),
			nil,
			nil,
		),
	}
}

func (c *ListCommand) Execute(ctx context.Context, cmd slack.SlashCommand, args []string) (slack.Msg, error) {
	// Use a reasonable limit (e.g., 100). For now, we don't handle a pagination token from the caller.
	rotations, _, err := c.repo.ListRotations(ctx, cmd.TeamID, 100, nil)
	if err != nil {
		return slack.Msg{}, err
	}

	if len(rotations) == 0 {
		return slack.Msg{ResponseType: slack.ResponseTypeInChannel, Text: "No rotations found."}, nil
	}

	text := "*Team Rotations:*\n"
	for _, r := range rotations {
		text += fmt.Sprintf("• `%s`: current owner <@%s>\n", r.RotationLabel, r.CurrentOwner)
	}

	return slack.Msg{ResponseType: slack.ResponseTypeInChannel, Text: text}, nil
}

// SetChannelCommand updates the rotation's Slack channel.
type SetChannelCommand struct {
	repo repository.RotationRepository
}

func NewSetChannelCommand(repo repository.RotationRepository) *SetChannelCommand {
	return &SetChannelCommand{repo: repo}
}

// StartCommand sets the rotation's start date to today at midnight UTC.
type StartCommand struct {
	repo repository.RotationRepository
}

func NewStartCommand(repo repository.RotationRepository) *StartCommand {
	return &StartCommand{repo: repo}
}

func (c *SetChannelCommand) Name() string {
	return "setchannel"
}

func (c *SetChannelCommand) HelpBlocks() []slack.Block {
	return []slack.Block{
		slack.NewHeaderBlock(
			slack.NewTextBlockObject("plain_text", "Set Channel Help", false, false),
		),
		slack.NewSectionBlock(
			slack.NewTextBlockObject("mrkdwn", "*Usage:* `/rotation setchannel <label> <#channel|clear>`", false, false),
			nil,
			nil,
		),
		slack.NewSectionBlock(
			slack.NewTextBlockObject("mrkdwn",
				"Associates a Slack channel with the rotation. Use `clear` to remove any channel association.",
				false, false),
			nil,
			nil,
		),
	}
}

func extractChannelID(mention string) (string, error) {
	// Accepts a typical Slack channel mention format: <#CHANNELID|channel_name>
	re := regexp.MustCompile(`<#(C[A-Z0-9]+)(?:\|[^>]+)?>`)
	match := re.FindStringSubmatch(mention)
	if len(match) != 2 {
		return "", fmt.Errorf("invalid channel mention format: %s", mention)
	}
	return match[1], nil
}

func (c *SetChannelCommand) Execute(ctx context.Context, cmd slack.SlashCommand, args []string) (slack.Msg, error) {
	if len(args) != 2 {
		return slack.Msg{
			ResponseType: slack.ResponseTypeEphemeral,
			Blocks:       slack.Blocks{BlockSet: c.HelpBlocks()},
		}, nil
	}

	label := args[0]
	channelArg := args[1]
	var channelID string
	if channelArg == "clear" {
		channelID = ""
	} else {
		var err error
		channelID, err = extractChannelID(channelArg)
		if err != nil {
			return slack.Msg{ //nolint:nilerr
				ResponseType: slack.ResponseTypeEphemeral,
				Text:         fmt.Sprintf("Invalid channel mention: %s", channelArg),
			}, nil
		}
	}

	r, err := c.repo.GetRotation(ctx, cmd.TeamID, label)
	if err != nil || r == nil {
		return slack.Msg{}, fmt.Errorf("rotation `%s` not found", label)
	}

	r.SlackChannelID = channelID
	if err := c.repo.UpsertRotation(ctx, *r); err != nil {
		return slack.Msg{}, err
	}

	var responseText string
	if channelID == "" {
		responseText = fmt.Sprintf("Slack channel association cleared for rotation `%s`.", label)
	} else {
		responseText = fmt.Sprintf("Rotation `%s` is now associated with channel <#%s>.", label, channelID)
	}

	return slack.Msg{ResponseType: slack.ResponseTypeInChannel, Text: responseText}, nil
}

func (c *StartCommand) Name() string {
	return "start"
}

func (c *StartCommand) HelpBlocks() []slack.Block {
	return []slack.Block{
		slack.NewHeaderBlock(
			slack.NewTextBlockObject("plain_text", "Start Rotation Help", false, false),
		),
		slack.NewSectionBlock(
			slack.NewTextBlockObject("mrkdwn",
				"*Usage:* `/rotation start <label> [YYYY-MM-DD]`\nSets the rotation start date to the specified date (at midnight UTC). If no date is provided, today is used.",
				false, false,
			),
			nil,
			nil,
		),
	}
}

func (c *StartCommand) Execute(ctx context.Context, cmd slack.SlashCommand, args []string) (slack.Msg, error) {
	// Expect 1 or 2 arguments: label and optional YYYY-MM-DD.
	if len(args) < 1 || len(args) > 2 {
		return slack.Msg{
			ResponseType: slack.ResponseTypeEphemeral,
			Blocks:       slack.Blocks{BlockSet: c.HelpBlocks()},
		}, nil
	}

	label := args[0]
	var startDate time.Time

	if len(args) == 2 {
		// Attempt to parse the provided date.
		parsed, err := time.Parse("2006-01-02", args[1])
		if err != nil {
			return slack.Msg{ //nolint:nilerr
				ResponseType: slack.ResponseTypeEphemeral,
				Text:         fmt.Sprintf("Invalid date format: `%s`. Please use YYYY-MM-DD.", args[1]),
			}, nil
		}
		startDate = parsed.UTC().Truncate(24 * time.Hour)
	} else {
		startDate = time.Now().UTC().Truncate(24 * time.Hour)
	}

	rotation, err := c.repo.GetRotation(ctx, cmd.TeamID, label)
	if err != nil || rotation == nil {
		return slack.Msg{}, fmt.Errorf("Rotation `%s` not found", label)
	}

	rotation.LastRotationDate = startDate
	rotation.NextRotationDate = calculateNextRotationDate(startDate, rotation.Frequency)

	if err := c.repo.UpsertRotation(ctx, *rotation); err != nil {
		return slack.Msg{}, err
	}

	var responseText string
	if len(args) == 2 {
		responseText = fmt.Sprintf("Rotation `%s` start set to %s at midnight UTC.", label, startDate.Format("2006-01-02"))
	} else {
		responseText = fmt.Sprintf("Rotation `%s` start set to today at midnight UTC.", label)
	}

	return slack.Msg{
		ResponseType: slack.ResponseTypeInChannel,
		Text:         responseText,
	}, nil
}

// TickCommand handles the tick subcommand.
type TickCommand struct {
	tickProcessor tick.Processor
	logger        zerolog.Logger
}

var _ SlackCommandHandler = (*TickCommand)(nil)

func NewTickCommand(tickProcessor tick.Processor, logger zerolog.Logger) *TickCommand {
	return &TickCommand{
		tickProcessor: tickProcessor,
		logger:        logger,
	}
}

func (c *TickCommand) Name() string {
	return "tick"
}

func (c *TickCommand) HelpBlocks() []slack.Block {
	return []slack.Block{
		slack.NewHeaderBlock(
			slack.NewTextBlockObject("plain_text", "Tick Help", false, false),
		),
		slack.NewSectionBlock(
			slack.NewTextBlockObject("mrkdwn", "*Usage:* `/rotation tick [teamID]`\n(Optional teamID to trigger the nuclear tick)", false, false),
			nil,
			nil,
		),
	}
}

func (c *TickCommand) Execute(ctx context.Context, cmd slack.SlashCommand, args []string) (slack.Msg, error) {
	var teamID string
	if len(args) > 0 {
		teamID = strings.TrimSpace(args[0])
	}
	err := c.tickProcessor.ProcessTick(ctx, teamID)
	if err != nil {
		return slack.Msg{}, fmt.Errorf("tick error: %w", err)
	}
	return slack.Msg{
		ResponseType: slack.ResponseTypeInChannel,
		Text:         "Tick executed successfully.",
	}, nil
}

func (c *TickCommand) HandleCommand(ctx context.Context, cmd slack.SlashCommand) (slack.Msg, error) {
	args := strings.Fields(strings.TrimSpace(cmd.Text))
	return c.Execute(ctx, cmd, args)
}

// Helper functions
func contains(slice []string, s string) bool {
	for _, item := range slice {
		if item == s {
			return true
		}
	}

	return false
}

func remove(slice []string, s string) []string {
	filtered := []string{}

	for _, item := range slice {
		if item != s {
			filtered = append(filtered, item)
		}
	}

	return filtered
}

func calculateNextRotationDate(lastDate time.Time, frequency string) time.Time {
	switch frequency {
	case "daily":
		return lastDate.AddDate(0, 0, 1)

	case "weekly":
		return lastDate.AddDate(0, 0, 7)

	case "biweekly":
		return lastDate.AddDate(0, 0, 14)

	case "monthly":
		return lastDate.AddDate(0, 1, 0)

	default:
		return lastDate.AddDate(0, 0, 7)
	}
}

func nextOwner(r *repository.Rotation) string {
	for i, owner := range r.RotationOrder {
		if owner == r.CurrentOwner {
			return r.RotationOrder[(i+1)%len(r.RotationOrder)]
		}
	}

	return r.RotationOrder[0]
}

// extractUserIDFromMention parses the Slack mention format and returns the user ID.
func extractUserIDFromMention(mention string) (string, error) {
	// Regular expression to match both <@USER_ID|username> and <@USER_ID> patterns
	re := regexp.MustCompile(`<@([UW][A-Z0-9]{8,})(?:\|[^>]+)?>`)

	match := re.FindStringSubmatch(mention)

	if len(match) != 2 {
		return "", fmt.Errorf("invalid mention format: %s", mention)
	}

	return match[1], nil
}
