package handler

import (
	"encoding/json"
	"fmt"
	"net/http"

	"github.com/rs/zerolog/log"
	"github.com/slack-go/slack"

	"{{ github_path }}/internal/config"
	"{{ github_path }}/internal/repository"
	slackcmd "{{ github_path }}/internal/slack"
)

// NewSlackHandler returns an http.Handler that processes Slack slash commands.
// It initializes a command registry with all commands and uses it to dispatch.
func NewSlackHandler(overrideRepo repository.OverrideRepository, rotationRepo repository.RotationRepository, slackConfig config.SlackConfig) http.Handler {
	logger := log.Logger

	registry := slackcmd.NewRegistry(logger)
	registry.Register("rotation", slackcmd.NewRotationCommand(rotationRepo))
	registry.Register("override", slackcmd.NewOverrideCommand(overrideRepo))

	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		ctx := r.Context()
		slashCmd, err := slack.SlashCommandParse(r)
		if err != nil {
			logger.Error().Err(err).Msg("Failed to parse slash command")
			http.Error(w, "Failed to parse slash command", http.StatusInternalServerError)
			return
		}

		logger.Info().
			Str("command", slashCmd.Command).
			Str("text", slashCmd.Text).
			Msg("Slack command received")

		msg, err := registry.Dispatch(ctx, slashCmd)
		if err != nil {
			logger.Error().Err(err).Msg("Error handling Slack command")
			http.Error(w, fmt.Sprintf("Error: %v", err), http.StatusInternalServerError)
			return
		}

		w.Header().Set("Content-Type", "application/json")
		if err := json.NewEncoder(w).Encode(msg); err != nil {
			logger.Error().Err(err).Msg("Failed to encode Slack response")
			http.Error(w, "Failed to encode response", http.StatusInternalServerError)
			return
		}
	})
}
